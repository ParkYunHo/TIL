# 2022.12.
2022년 12월 TLS

---

## Contents

 * [12/01 Thu](#1201)
 * [12/02 Fri](#1202)
 * [12/03 Sat](#1203)
 * [12/04 Sun](#1204)
 * [12/05 Mon](#1205)
 * [12/06 Tue](#1206)
 * [12/07 Wed](#1207)

---

### 12/01

1. MorningBear
   * `GraphqlTester` 는 Interface로 DI주입할 객체를 못찾는 문제 해결함!!!!
   * gradle clean으로 dependency정리하고 다시 받으니까 해결됨
   * 매칭되는 Bean을 못찾을때 무조건 `gradle clean` 한번 실행하고 할 것
2. 회사워크샵
   * 회사 다닌지 1-2년 됬는데 처음 워크샵 감


### 12/02

1. MorningBear
   * `GraphqlTester` 별도 header 추가하는 기능 찾아봤는데 없는것으로 보임
   * header에 access_token 추가하는 방식이 아닌 Step에서 Before방식으로 미리 context에 인증정보 저장
   * AOP Config에서는 Threadlocal context에 인증정보가 존재하면 bypass로 처리
     * AOP에서 `@Before` -> `@Around`로 변경 (API호출한 이후 context정보 삭제처리를 위해)
   * DB스키마랑 기능리스트 정리 어느정도 완료되서 프로젝트 구현 시작예정
     * DB스키마 JPA방식으로 엔티티테이블 생성 작업 (관계매핑 및 PK설정 필요)
     * 기능리스트에 필요한 Graphql스키마 작업
       * 우선 스키마 작업하고 Mapping메서드 작업
       * graphiql 통해서 스키마 제공
2. 넥스터즈 면접준비
   * DDD 끝나는 시기랑 넥스터즈 시작하는 시기랑 맞아서 무리없이 진행 가능
   * 공부자료 정리 및 면접자료 정리


### 12/03

1. MorningBear
   * 기능리스트가 계속 변경되고 있어서 부분적으로 작업예정
     * 전체 DB스키마 및 Graphql스키마 일괄작업시 계속 변경될 것 같아 일부씩 작업예정
   * 내정보 관련 기능작업
     * 뱃지정보, 카테고리정보, 내정보 관련 엔티티, repo, dto 작업
     * graphql스키마 및 Endpoint 작업
2. 넥스터즈 면접준비
   * 면접준비하면서 공부자료도 같이 정리중
   * 넥스터즈 repo 구경중인데 잘 짠 코드가 꽤 많음 - [nexters](https://github.com/Nexters)
     * [Travis CI 쓴 프로젝트](https://github.com/Nexters/banchan-server)
     * [DDD방식 프로젝트](https://github.com/Nexters/gamsung-routine-backend)


### 12/04

1. MorningBear
   * 뱃지, 카테고리, 탈퇴하기, 내정보 관련 작업 완료
   * cucumber feature 작업완료
   * 기존 H2에서 mysql로 전환 완료
     * OCI 인스턴스 한대 추가하여 MySQL서버 용도로 사용
   * GitAction 설정 및 DockerHub 설정 완료
   * OCI에 배포하고 나머지 작업 진행 예정
2. 넥스터즈 면접
   * 면접봄
   * 인성 + 기술 관련 질문 받음


### 12/05

1. MorningBear
   * OCI에 현재까지 작업물 배포하고 IOS팀에 공유
     * graphiql 통해서 스키마 확인 및 테스트 가능하도록 설정
   * 테이블간 연간관계 재설정
     * 1:1, 1:N 관계 재설정
     * cascade=REMOVE 방식으로 설정
     * 매핑테이블에 대해 별도 작성했던 삭제로직 제거하고 cascade로 삭제되도록 설정
   * 좋아요(응원하기) 기능까지 작업 완료
   * 사진(인증) 관련된 기능만 마무리하면 어느정도 끝남
   * 남은 작업
     * 애플로그인
     * TLS설정
     * AWS 전환 (오라클 클라우드는 개발용, AWS는 배포용)
     * account_id, access_token 소셜구분을 별도 암호화 알고리즘 짜서 적용할  (ex. Cipher)


### 12/06

1. MorningBear
   * 사진(인증) 관련 작업 완료
   * `@JoinColumn`
     * key로 쓰이는 컬럼인 경우 `insertable = false, updatable = false`로 설정해야 함
     * key로 쓰이는 컬럼이 아닌 경우, 위와 같이 false로 하면 데이터 저장,업데이트가 안되므로 default(true)로 설정해야 함
   * JPA 저장(save) 관련된 메서드는 `@Transactional` 선언해주면 좋은듯
     * save 메서드 내부적으로 이미 `@Transactional` 선언되어 있어 자동으로 트랜잭션으로 관리되기는 함
     * 그러나 하나의 메서드에서 여러 save 메서드를 사용할때, 하나의 save만 에러나더라도 전체를 롤백하고 싶으면 따로 `@Transactional` 선언하는게 좋음
   * 남은 작업
     * 리포트 기능
     * 소스코드 정리
     * 유효성체크 로직 추가
     * 애플로그인
     * account_id, access_token 소셜구분을 별도 암호화 알고리즘 짜서 적용할  (ex. Cipher)
     * 배포 : TLS설정, AWS 전환
2. CircuitBreaker
   * Hystrix는 2018년 이후 새로운 release버전이 나오지 않고 공식 repo에도 유지보수 상태라고 명시되어 있음
     * [Hystrix is no longer in active development, and is currently in maintenance mode](https://github.com/Netflix/Hystrix)
   * 따라서, Resilience4j 라이브러리를 쓰기로 함.
   * 5가지 패턴을 제공하며 이중에서 `@CircuitBreaker`만 사용 
     * `@Bulkhead`, `@CircuitBreaker`, `@RateLimiter`, `@Retry`, `@TimeLimiter`
   * CLOSE, OPEN, HALF_OPEN 3가지 상태로 나뉨
   * OPEN 상태까지는 구현하여 서킷 여는데까지 작업 완료
   * HALF_OPEN 상태에서 CLOSE, OPEN 상태 결정을 위한 Threshold 테스트중


### 12/07

1. CircuitBreaker
   * CircuitBreaker의 Buffer는 **RING BUFFER(원형큐)** 형식으로 구성되어 있음
     * 단순 Queue형태로 이해해서 BufferSize가 넘어가면 Buffer를 비우고 새로운 Buffer를 생성한다고 잘못 이해해서 한참 찾음
     * RingBuffer 형식으로 각 버퍼는 성공,실패값을 갖고 있고 index가 원형형태로 돌면서 버퍼값을 채우는 방식
     * 예를들어, bufferSize=3, failRate=100% 일때 success -> fail -> fail -> fail 일때 서킷OPEN 됨
     * [Resilience4j circuitBreaker docs](https://resilience4j.readme.io/v0.17.0/docs/circuitbreaker)
   * HALF_OPEN -> CLOSED 상태로 변경시 Buffer를 비우지만 서킷브레이커 대상 서비스의 성공/실패유무는 Buffer에 저장하지 않는다.
     ```
     >>> [fallback] cnt: 15, state: HALF_OPEN, succCall: 1, failCall: 1, notPermittedCall: 0, bufferCall: 2, failRate: -1.0
     >>> [정상실행] cnt: 16, state: CLOSED, succCall: 0, failCall: 0, notPermittedCall: 0, bufferCall: 0, failRate: -1.0
     ```
   * OPEN -> HALF_OPEN 상태로 변경시 위와같이 Buffer를 비우고, 서킷브레이커 대상 서비스의 성공/실패유무를 Buffer에 저장한다.
     ```
     >>> [서킷브레이커 오픈] cnt: 13, state: OPEN, succCall: 0, failCall: 3, notPermittedCall: 3, bufferCall: 3, failRate: 100.0
     >>> [정상실행] cnt: 14, state: HALF_OPEN, succCall: 1, failCall: 0, notPermittedCall: 0, bufferCall: 1, failRate: -1.0
     ```
   * FallBack 메서드에 선언되지 않은 Exception발생시 fallback메서드를 타지않고 바로 throw 한다
     * 아래같은 경우 fallback 메서드를 찾지 못해 callee() 메서드에서 바로 Exception1을 throw
       ```
       fun callee() { throw Exception1 }
       fun fallback1(Exception2) {}
       fun fallback2(Exception3) {}
       ```
     * 아래같은 경우 Exception1에 해당하는 fallback 메서드가 있으니 해당 메서드가 호출된다
        ```
       fun callee() { throw Exception1 }
       fun fallback1(Exception1) {}
       fun fallback2(Exception2) {}
       ```
     * 전체 Exception에 대한 fallback을 만들 경우 Throwable을 사용하면 된다
        ```
       fun callee() { throw Exception1 }
       fun fallback1(Throwable) {}
       ```
2. MorningBear
   * Cipher 통해서 암호화 알고리즘 구현
     * AES알고리즘의 key는 "16, 24 32"bytes만 가능
     ```
     interface AESConstants {
        // AES block size in bytes.
        int AES_BLOCK_SIZE = 16;
     
        // Valid AES key sizes in bytes.
        // NOTE: The values need to be listed in an *increasing* order
        // since DHKeyAgreement depends on this fact.
        int[] AES_KEYSIZES = { 16, 24, 32 };
     }
     ```
   * 다른 사용자 검색기능 완료
     * queryDSL로 nickname을 통한 JPA 검색쿼리 작업
     * kapt 툴을 이용하여 queryDSL 어노테이션 프로레싱 작업 진행
       * Kotlin은 kotlinc로 컴파일되어 Java로 작성된 Annotation Process로 정상처리되지 않음